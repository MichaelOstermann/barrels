---
aside: true
---

# namespace

```ts
interface NamespaceBarrelConfig {
    type: "namespace";
    name?: string | ((filePath: string) => string);
    types?: "merge" | "nested" | "flat";
    indentation?: number;
    banner?: boolean | string;
    directories?: string | string[];
    files: string | string[];
    include?: string | RegExp | readonly (string | RegExp)[];
    exclude?: string | RegExp | readonly (string | RegExp)[];
    output?: string | ((directory: string) => string);
    extensions?: "auto" | false | Record<string, string>;
    resolveExports?: boolean;
    transformSources?: (sources: Source[]) => Source[] | Promise<Source[]>;
    transformBarrel?: (barrel: string) => string | Promise<string>;
}
```

This config creates TypeScript namespace barrel files, with varying options for how to handle encountered type definitions.

## Example

::: code-group

```ts [barrels.config.ts]
import { defineConfig } from "@monstermann/barrels";

export default defineConfig([
    {
        type: "namespace",
        name: "Barrel",
        files: "./src/utils/*.ts",
        output: "./src/utils/index.ts",
    },
]);
```

```ts [src/utils/index.ts]
// Generated by @monstermann/barrels
/* eslint-disable */
/* prettier-ignore */
// dprint-ignore-file
// biome-ignore lint: disable

import { foo as _foo } from "./foo"
import { bar as _bar } from "./bar";
import { baz as _baz } from "./baz";

export namespace Barrel {
    export const foo = _foo;
    export const bar = _bar;
    export const baz = _baz;
}
```

:::

## Options

### name

```ts
interface NamespaceBarrelConfig {
    name?: string | ((filePath: string) => string);
}
```

Defines the name of the namespace. If omitted, the output file name will be used, or the output directory name if the file name was `index`.

### type

```ts
interface NamespaceBarrelConfig {
    types?: "merge" | "nested" | "flat";
}
```

This defines how type definitions should be handled, `flat` by default.

#### nested

Using this option will result with all type exports being included in the namespace.

```ts
import type { Foo as _Foo } from "./foo";
import type { Bar as _Bar } from "./bar";
import type { Baz as _Baz } from "./baz";

export namespace Foo {
    export type Foo = _Foo;
    export type Bar = _Bar;
    export type Baz = _Baz;
}
```

#### flat

Using this option will result with all type exports being re-exported as-is, including only values in the namespace.

```ts
import type { Foo as _Foo } from "./foo";

export type { Bar } from "./bar";
export type { Baz } from "./baz";
export type Foo = _Foo;

export namespace Foo {}
```

While this might look like a conflict, TypeScript is smart in figuring out whether `Foo` is the type definition or the namespace, depending on your usage.

#### merge

A mixture between `nested` and `flat` - Using this option will result with type exports that have the same name as the namespace being re-exported as-is, and all others are included in the namespace.

```ts
import type { Foo as _Foo } from "./foo";
import type { Bar as _Bar } from "./bar";
import type { Baz as _Baz } from "./baz";

export type Foo = _Foo;

export namespace Foo {
    export type Bar = _Bar;
    export type Baz = _Baz;
}
```

While this might look like a conflict, TypeScript is smart in figuring out whether `Foo` is the type definition or the namespace, depending on your usage.

### indentation

```ts
interface NamespaceBarrelConfig {
    indentation?: number;
}
```

Controls how many spaces to use for indenting, by default `4`.

<!--@include: ./options.md-->
