import type { GlobOptions } from "tinyglobby"
import type { BarrelsOutput } from "./types"
import { mkdir, writeFile } from "node:fs/promises"
import Path from "node:path"
import { glob } from "tinyglobby"
import { createFilter } from "unplugin-utils"
import { getBarrelsOutput } from "./defineConfig"

const barrelsCache = new Map<string, string>()

export const Barrel = {
    banner: `// Generated by @monstermann/barrels
/* eslint-disable */
/* prettier-ignore */
// dprint-ignore-file
// biome-ignore lint: disable`,
    async globDirectories(
        pattern: string | string[] | undefined,
        options?: Omit<GlobOptions, "absolute" | "patterns" | "onlyFiles" | "onlyDirectories" | "expandDirectories">,
    ): Promise<string[]> {
        if (!pattern || !pattern.length) return [process.cwd()]
        Barrel.watch(pattern, options?.cwd)
        return glob(pattern, {
            ...options,
            absolute: true,
            expandDirectories: false,
            onlyDirectories: true,
        })
            .then(paths => paths.map(path => Path.resolve(path)))
    },
    async globFiles(
        pattern: string | string[] | undefined,
        options?: Omit<GlobOptions, "absolute" | "patterns" | "onlyFiles" | "onlyDirectories">,
    ): Promise<string[]> {
        if (!pattern || !pattern.length) return []
        Barrel.watch(pattern, options?.cwd)
        return glob(pattern, {
            ...options,
            absolute: true,
            onlyFiles: true,
        })
    },
    isWatching(output: BarrelsOutput, path: string): boolean {
        path = Path.resolve(path)

        for (const matches of output.watchedPatterns.values()) {
            if (matches(path)) return true
        }

        return false
    },
    watch(patterns: string | string[], basePath?: string): void {
        if (!Array.isArray(patterns)) return Barrel.watch([patterns], basePath)

        const output = getBarrelsOutput()
        if (!output) return

        patterns
            .filter(Boolean)
            .map(pattern => Path.resolve(basePath ?? process.cwd(), pattern))
            .forEach((pattern) => {
                if (output.watchedPatterns.has(pattern)) return
                output.watchedPatterns.set(pattern, createFilter(pattern))
            })
    },
    async write(path: string, barrel: string): Promise<void> {
        // Add a trailing newline.
        barrel = `${barrel.trim()}\n`

        const targetDir = Path.dirname(path)

        // Check whether anything changed before writing, mostly there to prevent infinite loops in the file watcher.
        if (barrelsCache.get(path) === barrel) return
        barrelsCache.set(path, barrel)

        // Report to BarrelsRunner for pretty stdout outputs.
        const output = getBarrelsOutput()
        if (output) output.barrels.push({ barrel, path })

        mkdir(targetDir, { recursive: true })
        writeFile(path, barrel)
    },
}
