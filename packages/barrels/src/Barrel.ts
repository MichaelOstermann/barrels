import type { BarrelsOutput } from "./types"
import { mkdir, writeFile } from "node:fs/promises"
import Path from "node:path"
import { createFilter } from "unplugin-utils"
import { getBarrelsOutput } from "./internals/context"
import { Source } from "./Source"

const barrelsCache = new Map<string, string>()

export const Barrel = {
    ignoresHeader: `// Generated by @monstermann/barrels
/* eslint-disable */
/* prettier-ignore */
// dprint-ignore-file
// biome-ignore lint: disable`,
    constExport({ name, type, value }: {
        name: string
        type?: boolean
        value: string
    }): string {
        if (!name || !value) return ""
        return [
            "export",
            type ? "type" : "const",
            name,
            "=",
            `${value};`,
        ]
            .join(" ")
    },
    defaultExport({ alias, path, type }: {
        alias?: string
        path: string
        type?: boolean
    }): string {
        if (!path) return ""
        return [
            "export",
            type ? "type" : "",
            alias ? `{ default as ${alias} }` : "{ default }",
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    defaultImport({ alias, path, type }: {
        alias: string
        path: string
        type?: boolean
    }): string {
        if (!path || !alias) return ""
        return [
            "import",
            type ? "type" : "",
            alias,
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    export(source: Source): string {
        if (!source.export) {
            return Barrel.wildcardExport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Default") {
            return Barrel.defaultExport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Named") {
            return Barrel.namedExport({
                alias: source.alias,
                name: source.export.identifier,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Wildcard") {
            return Barrel.wildcardExport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        return ""
    },
    flat(sources: readonly Source[]): string {
        const types = sources
            .filter(source => Source.isTypeImport(source))
            .map(source => Barrel.export(source))
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b, "en-US"))

        const values = sources
            .filter(source => !Source.isTypeImport(source))
            .map(source => Barrel.export(source))
            .filter(Boolean)
            .sort((a, b) => a.localeCompare(b, "en-US"))

        return [...types, ...values].join("\n")
    },
    import(source: Source): string {
        if (!source.export) {
            return Barrel.wildcardImport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Default") {
            return Barrel.defaultImport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Named") {
            return Barrel.namedImport({
                alias: source.alias,
                name: source.export.identifier,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        if (source.export.type === "Wildcard") {
            return Barrel.wildcardImport({
                alias: source.alias,
                path: Source.importPath(source),
                type: Source.isTypeImport(source),
            })
        }

        return ""
    },
    isWatching(output: BarrelsOutput, path: string): boolean {
        path = Path.resolve(path)

        for (const matches of output.watchedPatterns.values()) {
            if (matches(path)) return true
        }

        return false
    },
    namedExport({ alias, name, path, type }: {
        alias?: string
        name: string
        path: string
        type?: boolean
    }): string {
        if (!name || !path) return ""
        return [
            "export",
            type ? "type" : "",
            "{",
            name,
            alias ? `as ${alias}` : "",
            "}",
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    namedImport({ alias, name, path, type }: {
        alias?: string
        name: string
        path: string
        type?: boolean
    }): string {
        if (!name || !path) return ""
        return [
            "import",
            type ? "type" : "",
            "{",
            name,
            alias ? `as ${alias}` : "",
            "}",
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    namespace(sources: readonly Source[], options: {
        indentation?: number
        name: string
        types?: "merge" | "nested" | "flat"
    }): string {
        const types = options.types || "flat"
        const candidates = sources.filter(source => Source.importName(source))
        const indentation = " ".repeat(options.indentation ?? 4)

        const typeImports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter((source) => {
                if (types === "flat") return false
                if (types === "nested") return true
                return options.name === Source.importName(source)
            })
            .map(source => Source.setImportAlias(source, `_${Source.importName(source)}`))
            .map(source => Barrel.import(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const valueImports = candidates
            .filter(source => !Source.isTypeImport(source))
            .map(source => Source.setImportAlias(source, `_${Source.importName(source)}`))
            .map(source => Barrel.import(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const typeReExports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter((source) => {
                if (types === "flat") return true
                if (types === "nested") return false
                return options.name !== Source.importName(source)
            })
            .map(source => Barrel.export(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const typeExports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter((source) => {
                if (types === "nested") return false
                return options.name === Source.importName(source)
            })
            .map(source => Barrel.constExport({
                name: Source.importName(source),
                type: true,
                value: `_${Source.importName(source)}`,
            }))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const header = [
            [typeImports, valueImports].filter(Boolean).join("\n"),
            [typeReExports, typeExports].filter(Boolean).join("\n"),
        ].filter(Boolean).join("\n\n")

        const typeExportsNested = candidates
            .filter(source => Source.isTypeImport(source))
            .filter((source) => {
                if (types === "flat") return false
                if (types === "nested") return true
                return options.name !== Source.importName(source)
            })
            .map(source => Barrel.constExport({
                name: Source.importName(source),
                type: true,
                value: `_${Source.importName(source)}`,
            }))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .map(line => `${indentation}${line}`)
            .join("\n")

        const valueExports = candidates
            .filter(source => !Source.isTypeImport(source))
            .map(source => Barrel.constExport({
                name: Source.importName(source),
                value: `_${Source.importName(source)}`,
            }))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .map(line => `${indentation}${line}`)
            .join("\n")

        const body = [typeExportsNested, valueExports]
            .filter(Boolean)
            .join("\n")

        return `${header}\n\nexport namespace ${options.name} {\n${body}\n}`
    },
    property({ key, value }: {
        key: string
        value: string
    }): string {
        if (!key || !value) return ""
        if (key === value) return `${key},`
        return `${key}: ${value},`
    },
    record(sources: readonly Source[], options: {
        indentation?: number
        name: string
    }): string {
        const candidates = sources.filter(source => Source.importName(source))
        const indentation = " ".repeat(options.indentation ?? 4)

        const typeImports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter(source => options.name === Source.importName(source))
            .map(source => Source.setImportAlias(source, `_${Source.importName(source)}`))
            .map(source => Barrel.import(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const valueImports = candidates
            .filter(source => !Source.isTypeImport(source))
            .map(source => Barrel.import(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const typeReExports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter(source => options.name !== Source.importName(source))
            .map(source => Barrel.export(source))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const typeExports = candidates
            .filter(source => Source.isTypeImport(source))
            .filter(source => options.name === Source.importName(source))
            .map(source => Barrel.constExport({
                name: Source.importName(source),
                type: true,
                value: `_${Source.importName(source)}`,
            }))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .join("\n")

        const header = [
            [typeImports, valueImports].filter(Boolean).join("\n"),
            [typeReExports, typeExports].filter(Boolean).join("\n"),
        ].filter(Boolean).join("\n\n")

        const props = candidates
            .filter(source => !Source.isTypeImport(source))
            .map(source => Barrel.property({
                key: Source.importName(source),
                value: Source.importName(source),
            }))
            .sort((a, b) => a.localeCompare(b, "en-US"))
            .map(line => `${indentation}${line}`)
            .join("\n")

        return `${header}\n\nexport const ${options.name} = {\n${props}\n}`
    },
    watch(patterns: string | string[], basePath?: string): void {
        if (!Array.isArray(patterns)) return Barrel.watch([patterns], basePath)

        const output = getBarrelsOutput()
        if (!output) return

        patterns
            .filter(Boolean)
            .map(pattern => Path.resolve(basePath ?? process.cwd(), pattern))
            .forEach((pattern) => {
                if (output.watchedPatterns.has(pattern)) return
                output.watchedPatterns.set(pattern, createFilter(pattern))
            })
    },
    wildcardExport({ alias, path, type }: {
        alias?: string
        path: string
        type?: boolean
    }): string {
        if (!path) return ""
        return [
            "export",
            type ? "type" : "",
            "*",
            alias ? `as ${alias}` : "",
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    wildcardImport({ alias, path, type }: {
        alias: string
        path: string
        type?: boolean
    }): string {
        if (!path || !alias) return ""
        return [
            "import",
            type ? "type" : "",
            "*",
            alias ? `as ${alias}` : "",
            "from",
            `"${path}";`,
        ]
            .filter(Boolean)
            .join(" ")
    },
    async write(path: string, barrel: string): Promise<void> {
        // Add a trailing newline.
        barrel = `${barrel.trim()}\n`

        const targetDir = Path.dirname(path)

        // Check whether anything changed before writing, mostly there to prevent infinite loops in the file watcher.
        if (barrelsCache.get(path) === barrel) return
        barrelsCache.set(path, barrel)

        // Report to BarrelsRunner for pretty stdout outputs.
        const output = getBarrelsOutput()
        if (output) output.barrels.push({ barrel, path })

        mkdir(targetDir, { recursive: true })
        writeFile(path, barrel)
    },
}
